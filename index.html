<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Interactive Rotating Globe</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden;
            background-color: #0a192f;
            font-family: Arial, sans-serif;
        }
        canvas { 
            display: block; 
        }
        #controlPanel {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(10, 25, 47, 0.9);
            padding: 20px;
            border-radius: 10px;
            color: white;
            z-index: 1000;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            backdrop-filter: blur(5px);
            min-width: 250px;
        }
        .control-group {
            margin-bottom: 15px;
        }
        .control-group label {
            display: block;
            margin-bottom: 5px;
            color: #64ffda;
            font-size: 0.9em;
        }
        input[type="range"] {
            width: 100%;
            height: 5px;
            border-radius: 5px;
            background: #1a2f4c;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        input[type="range"]:hover {
            opacity: 1;
        }
        .value-display {
            float: right;
            font-size: 0.8em;
            color: #8892b0;
        }
        h3 {
            margin-top: 0;
            color: #64ffda;
            border-bottom: 1px solid #1a2f4c;
            padding-bottom: 10px;
            margin-bottom: 15px;
        }
    </style>
</head>
<body>
    <div id="controlPanel">
        <h3>Light Controls</h3>
        <div class="control-group">
            <label>Ambient Light <span class="value-display" id="ambientValue">0.4</span></label>
            <input type="range" id="ambientLight" min="0" max="1" step="0.1" value="0.4">
        </div>
        <div class="control-group">
            <label>Directional Light <span class="value-display" id="directionalValue">1.0</span></label>
            <input type="range" id="directionalLight" min="0" max="2" step="0.1" value="1">
        </div>
        <div class="control-group">
            <label>Point Light <span class="value-display" id="pointValue">0.5</span></label>
            <input type="range" id="pointLight" min="0" max="1" step="0.1" value="0.5">
        </div>
        <div class="control-group">
            <label>Rim Light <span class="value-display" id="rimValue">0.3</span></label>
            <input type="range" id="rimLight" min="0" max="1" step="0.1" value="0.3">
        </div>
        <div class="control-group">
            <label>Atmosphere Opacity <span class="value-display" id="atmosphereValue">0.1</span></label>
            <input type="range" id="atmosphereOpacity" min="0" max="0.3" step="0.01" value="0.1">
        </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
    let scene, camera, renderer, globe, starField, atmosphere;
    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };
    let autoRotationSpeed = 0.001;
    let rotationLimitY = Math.PI / 3;
    let lights = {};
    let targetRotation = { x: 0, y: 0 };
    let currentRotation = { x: 0, y: 0 };
    let momentum = 0;
    let isScrolling = false;
    let scrollSpeed = 0.1;

    function createStarField() {
        const starsGeometry = new THREE.BufferGeometry();
        const starsMaterial = new THREE.PointsMaterial({
            color: 0xFFFFFF,
            size: 0.1,
            transparent: true,
            opacity: 0.8,
            sizeAttenuation: true
        });

        const starsVertices = [];
        for(let i = 0; i < 5000; i++) {
            const x = (Math.random() - 0.5) * 2000;
            const y = (Math.random() - 0.5) * 2000;
            const z = -Math.random() * 2000;
            starsVertices.push(x, y, z);
        }

        starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
        starField = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(starField);
    }

    function setupLighting() {
        lights.ambient = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(lights.ambient);

        lights.directional = new THREE.DirectionalLight(0xffffff, 1);
        lights.directional.position.set(5, 3, 5);
        scene.add(lights.directional);

        lights.point = new THREE.PointLight(0x3498db, 0.5);
        lights.point.position.set(-10, 5, -10);
        scene.add(lights.point);

        lights.rim = new THREE.DirectionalLight(0x3498db, 0.3);
        lights.rim.position.set(-5, 0, -5);
        scene.add(lights.rim);
    }

    function setupLightControls() {
        document.getElementById('ambientLight').addEventListener('input', function(e) {
            lights.ambient.intensity = parseFloat(e.target.value);
            document.getElementById('ambientValue').textContent = e.target.value;
        });

        document.getElementById('directionalLight').addEventListener('input', function(e) {
            lights.directional.intensity = parseFloat(e.target.value);
            document.getElementById('directionalValue').textContent = e.target.value;
        });

        document.getElementById('pointLight').addEventListener('input', function(e) {
            lights.point.intensity = parseFloat(e.target.value);
            document.getElementById('pointValue').textContent = e.target.value;
        });

        document.getElementById('rimLight').addEventListener('input', function(e) {
            lights.rim.intensity = parseFloat(e.target.value);
            document.getElementById('rimValue').textContent = e.target.value;
        });

        document.getElementById('atmosphereOpacity').addEventListener('input', function(e) {
            if (atmosphere) {
                atmosphere.material.opacity = parseFloat(e.target.value);
                document.getElementById('atmosphereValue').textContent = e.target.value;
            }
        });
    }

    function handleMomentumScroll() {
        if (Math.abs(momentum) > 0.0001) {
            targetRotation.y += momentum;
            momentum *= 0.95;
            requestAnimationFrame(handleMomentumScroll);
        } else {
            isScrolling = false;
        }
    }

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color('#0a192f');

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.z = 4;

        renderer = new THREE.WebGLRenderer({ 
            antialias: true,
            alpha: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        createStarField();
        setupLighting();

        const globeContainer = new THREE.Object3D();
        scene.add(globeContainer);

        const geometry = new THREE.SphereGeometry(1.8, 64, 64);
        const texture = new THREE.TextureLoader().load(
            'https://threejs.org/examples/textures/land_ocean_ice_cloud_2048.jpg',
            function() {
                const material = new THREE.MeshPhongMaterial({ 
                    map: texture,
                    specular: new THREE.Color('grey'),
                    shininess: 15,
                    bumpScale: 0.05
                });

                globe = new THREE.Mesh(geometry, material);
                globeContainer.add(globe);

                const atmosphereGeometry = new THREE.SphereGeometry(1.85, 64, 64);
                const atmosphereMaterial = new THREE.MeshPhongMaterial({
                    color: 0x3498db,
                    transparent: true,
                    opacity: 0.1,
                    side: THREE.BackSide
                });
                atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
                globeContainer.add(atmosphere);

                setupLightControls();
            }
        );

        document.addEventListener('mousedown', onMouseDown, false);
        document.addEventListener('mouseup', onMouseUp, false);
        document.addEventListener('mousemove', onMouseMove, false);
        window.addEventListener('resize', onWindowResize, false);
        renderer.domElement.addEventListener('wheel', onWheel, { passive: false });
        renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
        renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
        renderer.domElement.addEventListener('touchend', onTouchEnd, false);

        animate();
    }

    function onWheel(event) {
        if (globe) {
            event.preventDefault();
            const delta = event.deltaY;
            momentum += delta * 0.0001;
            
            if (!isScrolling) {
                isScrolling = true;
                handleMomentumScroll();
            }
        }
    }

    function onMouseDown(event) {
        isDragging = true;
        previousMousePosition = {
            x: event.clientX,
            y: event.clientY
        };
    }

    function onMouseUp(event) {
        isDragging = false;
    }

    function onMouseMove(event) {
        if (isDragging && globe) {
            const deltaMove = {
                x: event.clientX - previousMousePosition.x,
                y: event.clientY - previousMousePosition.y
            };

            targetRotation.y -= toRadians(deltaMove.x * 0.5);
            targetRotation.x += toRadians(deltaMove.y * 0.5);

            targetRotation.x = Math.max(-rotationLimitY, Math.min(rotationLimitY, targetRotation.x));

            previousMousePosition = {
                x: event.clientX,
                y: event.clientY
            };
        }
    }

    function onTouchStart(event) {
        isDragging = true;
        previousMousePosition = {
            x: event.touches[0].clientX,
            y: event.touches[0].clientY
        };
    }

    function onTouchMove(event) {
        if (isDragging && globe) {
            event.preventDefault();
            const deltaMove = {
                x: event.touches[0].clientX - previousMousePosition.x,
                y: event.touches[0].clientY - previousMousePosition.y
            };

            targetRotation.y -= toRadians(deltaMove.x * 0.5);
            targetRotation.x += toRadians(deltaMove.y * 0.5);

            targetRotation.x = Math.max(-rotationLimitY, Math.min(rotationLimitY, targetRotation.x));

            previousMousePosition = {
                x: event.touches[0].clientX,
                y: event.touches[0].clientY
            };
        }
    }

    function onTouchEnd() {
        isDragging = false;
    }

    function toRadians(angle) {
        return angle * (Math.PI / 180);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);

        if (globe) {
            if (!isDragging) {
                targetRotation.y -= autoRotationSpeed;
            }

            currentRotation.x += (targetRotation.x - currentRotation.x) * scrollSpeed;
            currentRotation.y += (targetRotation.y - currentRotation.y) * scrollSpeed;

            const rotationMatrix = new THREE.Matrix4();
            const quaternionX = new THREE.Quaternion();
            const quaternionY = new THREE.Quaternion();

            quaternionX.setFromAxisAngle(new THREE.Vector3(1, 0, 0), currentRotation.x);
            quaternionY.setFromAxisAngle(new THREE.Vector3(0, 1, 0), currentRotation.y);
            
            quaternionX.multiply(quaternionY);
            rotationMatrix.makeRotationFromQuaternion(quaternionX);
            
            globe.parent.setRotationFromMatrix(rotationMatrix);
        }

        if (starField) {
            starField.rotation.y += 0.0001;
        }

        renderer.render(scene, camera);
    }

    init();
</script>
</body>
</html>
